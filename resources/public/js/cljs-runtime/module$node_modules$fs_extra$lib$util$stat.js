shadow$provide.module$node_modules$fs_extra$lib$util$stat=function(global,require,module,exports){function getStats(src,dest,opts){opts=opts.dereference?file=>fs.stat(file,{bigint:!0}):file=>fs.lstat(file,{bigint:!0});return Promise.all([opts(src),opts(dest).catch(err=>{if("ENOENT"===err.code)return null;throw err;})]).then(([srcStat,destStat])=>({srcStat,destStat}))}function getStatsSync(src,dest,opts){let destStat;opts=opts.dereference?file=>fs.statSync(file,{bigint:!0}):file=>fs.lstatSync(file,
{bigint:!0});src=opts(src);try{destStat=opts(dest)}catch(err){if("ENOENT"===err.code)return{srcStat:src,destStat:null};throw err;}return{srcStat:src,destStat}}function checkParentPaths(src,srcStat,dest,funcName,cb){const srcParent=path.resolve(path.dirname(src)),destParent=path.resolve(path.dirname(dest));if(destParent===srcParent||destParent===path.parse(destParent).root)return cb();fs.stat(destParent,{bigint:!0},(err,destStat)=>err?"ENOENT"===err.code?cb():cb(err):areIdentical(srcStat,destStat)?
cb(Error(errMsg(src,dest,funcName))):checkParentPaths(src,srcStat,destParent,funcName,cb))}function checkParentPathsSync(src,srcStat,dest,funcName){const srcParent=path.resolve(path.dirname(src)),destParent=path.resolve(path.dirname(dest));if(destParent!==srcParent&&destParent!==path.parse(destParent).root){try{var destStat=fs.statSync(destParent,{bigint:!0})}catch(err){if("ENOENT"===err.code)return;throw err;}if(areIdentical(srcStat,destStat))throw Error(errMsg(src,dest,funcName));return checkParentPathsSync(src,
srcStat,destParent,funcName)}}function areIdentical(srcStat,destStat){return destStat.ino&&destStat.dev&&destStat.ino===srcStat.ino&&destStat.dev===srcStat.dev}function isSrcSubdir(src,dest){src=path.resolve(src).split(path.sep).filter(i=>i);const destArr=path.resolve(dest).split(path.sep).filter(i=>i);return src.reduce((acc,cur,i)=>acc&&destArr[i]===cur,!0)}function errMsg(src,dest,funcName){return`Cannot ${funcName} '${src}' to a subdirectory of itself, '${dest}'.`}const fs=require("module$node_modules$fs_extra$lib$fs$index"),
path=require("module$node_modules$path_browserify$index"),util=require("module$node_modules$util$util");module.exports={checkPaths:function(src,dest,funcName,opts,cb){util.callbackify(getStats)(src,dest,opts,(err,stats)=>{if(err)return cb(err);const {srcStat,destStat}=stats;if(destStat){if(areIdentical(srcStat,destStat))return err=path.basename(src),stats=path.basename(dest),"move"===funcName&&err!==stats&&err.toLowerCase()===stats.toLowerCase()?cb(null,{srcStat,destStat,isChangingCase:!0}):cb(Error("Source and destination must not be the same."));
if(srcStat.isDirectory()&&!destStat.isDirectory())return cb(Error(`Cannot overwrite non-directory '${dest}' with directory '${src}'.`));if(!srcStat.isDirectory()&&destStat.isDirectory())return cb(Error(`Cannot overwrite directory '${dest}' with non-directory '${src}'.`))}return srcStat.isDirectory()&&isSrcSubdir(src,dest)?cb(Error(errMsg(src,dest,funcName))):cb(null,{srcStat,destStat})})},checkPathsSync:function(src,dest,funcName,opts){const {srcStat,destStat}=getStatsSync(src,dest,opts);if(destStat){if(areIdentical(srcStat,
destStat)){src=path.basename(src);dest=path.basename(dest);if("move"===funcName&&src!==dest&&src.toLowerCase()===dest.toLowerCase())return{srcStat,destStat,isChangingCase:!0};throw Error("Source and destination must not be the same.");}if(srcStat.isDirectory()&&!destStat.isDirectory())throw Error(`Cannot overwrite non-directory '${dest}' with directory '${src}'.`);if(!srcStat.isDirectory()&&destStat.isDirectory())throw Error(`Cannot overwrite directory '${dest}' with non-directory '${src}'.`);}if(srcStat.isDirectory()&&
isSrcSubdir(src,dest))throw Error(errMsg(src,dest,funcName));return{srcStat,destStat}},checkParentPaths,checkParentPathsSync,isSrcSubdir,areIdentical}}
//# sourceMappingURL=module$node_modules$fs_extra$lib$util$stat.js.map
