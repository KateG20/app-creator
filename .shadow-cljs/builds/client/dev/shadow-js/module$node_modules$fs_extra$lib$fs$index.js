["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/fs-extra/lib/fs/index.js"],"~:js","shadow$provide.module$node_modules$fs_extra$lib$fs$index=function(global,require,module,exports){global=require(\"module$node_modules$process$browser\");\"use strict\";const u=require(\"module$node_modules$universalify$index\").fromCallback,fs=require(\"module$node_modules$graceful_fs$graceful_fs\");require=\"access appendFile chmod chown close copyFile fchmod fchown fdatasync fstat fsync ftruncate futimes lchmod lchown link lstat mkdir mkdtemp open opendir readdir readFile readlink realpath rename rm rmdir stat symlink truncate unlink utimes writeFile\".split(\" \").filter(key=>\n\"function\"===typeof fs[key]);Object.assign(exports,fs);require.forEach(method=>{exports[method]=u(fs[method])});exports.exists=function(filename,callback){return\"function\"===typeof callback?fs.exists(filename,callback):new Promise(resolve=>fs.exists(filename,resolve))};exports.read=function(fd,buffer$jscomp$0,offset,length,position,callback){return\"function\"===typeof callback?fs.read(fd,buffer$jscomp$0,offset,length,position,callback):new Promise((resolve,reject)=>{fs.read(fd,buffer$jscomp$0,offset,\nlength,position,(err,bytesRead,buffer)=>{if(err)return reject(err);resolve({bytesRead,buffer})})})};exports.write=function(fd,buffer$jscomp$0,...args){return\"function\"===typeof args[args.length-1]?fs.write(fd,buffer$jscomp$0,...args):new Promise((resolve,reject)=>{fs.write(fd,buffer$jscomp$0,...args,(err,bytesWritten,buffer)=>{if(err)return reject(err);resolve({bytesWritten,buffer})})})};exports.readv=function(fd,buffers$jscomp$0,...args){return\"function\"===typeof args[args.length-1]?fs.readv(fd,\nbuffers$jscomp$0,...args):new Promise((resolve,reject)=>{fs.readv(fd,buffers$jscomp$0,...args,(err,bytesRead,buffers)=>{if(err)return reject(err);resolve({bytesRead,buffers})})})};exports.writev=function(fd,buffers$jscomp$0,...args){return\"function\"===typeof args[args.length-1]?fs.writev(fd,buffers$jscomp$0,...args):new Promise((resolve,reject)=>{fs.writev(fd,buffers$jscomp$0,...args,(err,bytesWritten,buffers)=>{if(err)return reject(err);resolve({bytesWritten,buffers})})})};\"function\"===typeof fs.realpath.native?\nexports.realpath.native=u(fs.realpath.native):global.emitWarning(\"fs.realpath.native is not a function. Is fs being monkey-patched?\",\"Warning\",\"fs-extra-WARN0003\")}","~:source","shadow$provide[\"module$node_modules$fs_extra$lib$fs$index\"] = function(global,require,module,exports) {\nvar process = require('process');\n'use strict'\n// This is adapted from https://github.com/normalize/mz\n// Copyright (c) 2014-2016 Jonathan Ong me@jongleberry.com and Contributors\nconst u = require('universalify').fromCallback\nconst fs = require('graceful-fs')\n\nconst api = [\n  'access',\n  'appendFile',\n  'chmod',\n  'chown',\n  'close',\n  'copyFile',\n  'fchmod',\n  'fchown',\n  'fdatasync',\n  'fstat',\n  'fsync',\n  'ftruncate',\n  'futimes',\n  'lchmod',\n  'lchown',\n  'link',\n  'lstat',\n  'mkdir',\n  'mkdtemp',\n  'open',\n  'opendir',\n  'readdir',\n  'readFile',\n  'readlink',\n  'realpath',\n  'rename',\n  'rm',\n  'rmdir',\n  'stat',\n  'symlink',\n  'truncate',\n  'unlink',\n  'utimes',\n  'writeFile'\n].filter(key => {\n  // Some commands are not available on some systems. Ex:\n  // fs.cp was added in Node.js v16.7.0\n  // fs.lchown is not available on at least some Linux\n  return typeof fs[key] === 'function'\n})\n\n// Export cloned fs:\nObject.assign(exports, fs)\n\n// Universalify async methods:\napi.forEach(method => {\n  exports[method] = u(fs[method])\n})\n\n// We differ from mz/fs in that we still ship the old, broken, fs.exists()\n// since we are a drop-in replacement for the native module\nexports.exists = function (filename, callback) {\n  if (typeof callback === 'function') {\n    return fs.exists(filename, callback)\n  }\n  return new Promise(resolve => {\n    return fs.exists(filename, resolve)\n  })\n}\n\n// fs.read(), fs.write(), fs.readv(), & fs.writev() need special treatment due to multiple callback args\n\nexports.read = function (fd, buffer, offset, length, position, callback) {\n  if (typeof callback === 'function') {\n    return fs.read(fd, buffer, offset, length, position, callback)\n  }\n  return new Promise((resolve, reject) => {\n    fs.read(fd, buffer, offset, length, position, (err, bytesRead, buffer) => {\n      if (err) return reject(err)\n      resolve({ bytesRead, buffer })\n    })\n  })\n}\n\n// Function signature can be\n// fs.write(fd, buffer[, offset[, length[, position]]], callback)\n// OR\n// fs.write(fd, string[, position[, encoding]], callback)\n// We need to handle both cases, so we use ...args\nexports.write = function (fd, buffer, ...args) {\n  if (typeof args[args.length - 1] === 'function') {\n    return fs.write(fd, buffer, ...args)\n  }\n\n  return new Promise((resolve, reject) => {\n    fs.write(fd, buffer, ...args, (err, bytesWritten, buffer) => {\n      if (err) return reject(err)\n      resolve({ bytesWritten, buffer })\n    })\n  })\n}\n\n// Function signature is\n// s.readv(fd, buffers[, position], callback)\n// We need to handle the optional arg, so we use ...args\nexports.readv = function (fd, buffers, ...args) {\n  if (typeof args[args.length - 1] === 'function') {\n    return fs.readv(fd, buffers, ...args)\n  }\n\n  return new Promise((resolve, reject) => {\n    fs.readv(fd, buffers, ...args, (err, bytesRead, buffers) => {\n      if (err) return reject(err)\n      resolve({ bytesRead, buffers })\n    })\n  })\n}\n\n// Function signature is\n// s.writev(fd, buffers[, position], callback)\n// We need to handle the optional arg, so we use ...args\nexports.writev = function (fd, buffers, ...args) {\n  if (typeof args[args.length - 1] === 'function') {\n    return fs.writev(fd, buffers, ...args)\n  }\n\n  return new Promise((resolve, reject) => {\n    fs.writev(fd, buffers, ...args, (err, bytesWritten, buffers) => {\n      if (err) return reject(err)\n      resolve({ bytesWritten, buffers })\n    })\n  })\n}\n\n// fs.realpath.native sometimes not available if fs is monkey-patched\nif (typeof fs.realpath.native === 'function') {\n  exports.realpath.native = u(fs.realpath.native)\n} else {\n  process.emitWarning(\n    'fs.realpath.native is not a function. Is fs being monkey-patched?',\n    'Warning', 'fs-extra-WARN0003'\n  )\n}\n\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$module$node_modules$process$browser","~$module$node_modules$universalify$index","~$shadow.js","~$module$node_modules$graceful_fs$graceful_fs"]],"~:properties",["^5",["writev","native","read","bytesWritten","buffer","readv","bytesRead","exists","write","buffers"]],"~:compiled-at",1683799130881,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$fs_extra$lib$fs$index.js\",\n\"lineCount\":5,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/fs-extra/lib/fs/index.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$fs_extra$lib$fs$index\\\"] = function(global,require,module,exports) {\\nvar process = require('process');\\n'use strict'\\n// This is adapted from https://github.com/normalize/mz\\n// Copyright (c) 2014-2016 Jonathan Ong me@jongleberry.com and Contributors\\nconst u = require('universalify').fromCallback\\nconst fs = require('graceful-fs')\\n\\nconst api = [\\n  'access',\\n  'appendFile',\\n  'chmod',\\n  'chown',\\n  'close',\\n  'copyFile',\\n  'fchmod',\\n  'fchown',\\n  'fdatasync',\\n  'fstat',\\n  'fsync',\\n  'ftruncate',\\n  'futimes',\\n  'lchmod',\\n  'lchown',\\n  'link',\\n  'lstat',\\n  'mkdir',\\n  'mkdtemp',\\n  'open',\\n  'opendir',\\n  'readdir',\\n  'readFile',\\n  'readlink',\\n  'realpath',\\n  'rename',\\n  'rm',\\n  'rmdir',\\n  'stat',\\n  'symlink',\\n  'truncate',\\n  'unlink',\\n  'utimes',\\n  'writeFile'\\n].filter(key => {\\n  // Some commands are not available on some systems. Ex:\\n  // fs.cp was added in Node.js v16.7.0\\n  // fs.lchown is not available on at least some Linux\\n  return typeof fs[key] === 'function'\\n})\\n\\n// Export cloned fs:\\nObject.assign(exports, fs)\\n\\n// Universalify async methods:\\napi.forEach(method => {\\n  exports[method] = u(fs[method])\\n})\\n\\n// We differ from mz/fs in that we still ship the old, broken, fs.exists()\\n// since we are a drop-in replacement for the native module\\nexports.exists = function (filename, callback) {\\n  if (typeof callback === 'function') {\\n    return fs.exists(filename, callback)\\n  }\\n  return new Promise(resolve => {\\n    return fs.exists(filename, resolve)\\n  })\\n}\\n\\n// fs.read(), fs.write(), fs.readv(), & fs.writev() need special treatment due to multiple callback args\\n\\nexports.read = function (fd, buffer, offset, length, position, callback) {\\n  if (typeof callback === 'function') {\\n    return fs.read(fd, buffer, offset, length, position, callback)\\n  }\\n  return new Promise((resolve, reject) => {\\n    fs.read(fd, buffer, offset, length, position, (err, bytesRead, buffer) => {\\n      if (err) return reject(err)\\n      resolve({ bytesRead, buffer })\\n    })\\n  })\\n}\\n\\n// Function signature can be\\n// fs.write(fd, buffer[, offset[, length[, position]]], callback)\\n// OR\\n// fs.write(fd, string[, position[, encoding]], callback)\\n// We need to handle both cases, so we use ...args\\nexports.write = function (fd, buffer, ...args) {\\n  if (typeof args[args.length - 1] === 'function') {\\n    return fs.write(fd, buffer, ...args)\\n  }\\n\\n  return new Promise((resolve, reject) => {\\n    fs.write(fd, buffer, ...args, (err, bytesWritten, buffer) => {\\n      if (err) return reject(err)\\n      resolve({ bytesWritten, buffer })\\n    })\\n  })\\n}\\n\\n// Function signature is\\n// s.readv(fd, buffers[, position], callback)\\n// We need to handle the optional arg, so we use ...args\\nexports.readv = function (fd, buffers, ...args) {\\n  if (typeof args[args.length - 1] === 'function') {\\n    return fs.readv(fd, buffers, ...args)\\n  }\\n\\n  return new Promise((resolve, reject) => {\\n    fs.readv(fd, buffers, ...args, (err, bytesRead, buffers) => {\\n      if (err) return reject(err)\\n      resolve({ bytesRead, buffers })\\n    })\\n  })\\n}\\n\\n// Function signature is\\n// s.writev(fd, buffers[, position], callback)\\n// We need to handle the optional arg, so we use ...args\\nexports.writev = function (fd, buffers, ...args) {\\n  if (typeof args[args.length - 1] === 'function') {\\n    return fs.writev(fd, buffers, ...args)\\n  }\\n\\n  return new Promise((resolve, reject) => {\\n    fs.writev(fd, buffers, ...args, (err, bytesWritten, buffers) => {\\n      if (err) return reject(err)\\n      resolve({ bytesWritten, buffers })\\n    })\\n  })\\n}\\n\\n// fs.realpath.native sometimes not available if fs is monkey-patched\\nif (typeof fs.realpath.native === 'function') {\\n  exports.realpath.native = u(fs.realpath.native)\\n} else {\\n  process.emitWarning(\\n    'fs.realpath.native is not a function. Is fs being monkey-patched?',\\n    'Warning', 'fs-extra-WARN0003'\\n  )\\n}\\n\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"process\",\"u\",\"fromCallback\",\"fs\",\"api\",\"filter\",\"key\",\"Object\",\"assign\",\"forEach\",\"method\",\"exists\",\"exports.exists\",\"filename\",\"callback\",\"Promise\",\"resolve\",\"read\",\"exports.read\",\"fd\",\"buffer\",\"offset\",\"length\",\"position\",\"reject\",\"err\",\"bytesRead\",\"write\",\"exports.write\",\"args\",\"bytesWritten\",\"readv\",\"exports.readv\",\"buffers\",\"writev\",\"exports.writev\",\"realpath\",\"native\",\"emitWarning\"]\n}\n"]