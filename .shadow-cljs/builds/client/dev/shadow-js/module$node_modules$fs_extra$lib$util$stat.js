["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/fs-extra/lib/util/stat.js"],"~:js","shadow$provide.module$node_modules$fs_extra$lib$util$stat=function(global,require,module,exports){function getStats(src,dest,opts){opts=opts.dereference?file=>fs.stat(file,{bigint:!0}):file=>fs.lstat(file,{bigint:!0});return Promise.all([opts(src),opts(dest).catch(err=>{if(\"ENOENT\"===err.code)return null;throw err;})]).then(([srcStat,destStat])=>({srcStat,destStat}))}function getStatsSync(src,dest,opts){let destStat;opts=opts.dereference?file=>fs.statSync(file,{bigint:!0}):file=>fs.lstatSync(file,\n{bigint:!0});src=opts(src);try{destStat=opts(dest)}catch(err){if(\"ENOENT\"===err.code)return{srcStat:src,destStat:null};throw err;}return{srcStat:src,destStat}}function checkParentPaths(src,srcStat,dest,funcName,cb){const srcParent=path.resolve(path.dirname(src)),destParent=path.resolve(path.dirname(dest));if(destParent===srcParent||destParent===path.parse(destParent).root)return cb();fs.stat(destParent,{bigint:!0},(err,destStat)=>err?\"ENOENT\"===err.code?cb():cb(err):areIdentical(srcStat,destStat)?\ncb(Error(errMsg(src,dest,funcName))):checkParentPaths(src,srcStat,destParent,funcName,cb))}function checkParentPathsSync(src,srcStat,dest,funcName){const srcParent=path.resolve(path.dirname(src)),destParent=path.resolve(path.dirname(dest));if(destParent!==srcParent&&destParent!==path.parse(destParent).root){try{var destStat=fs.statSync(destParent,{bigint:!0})}catch(err){if(\"ENOENT\"===err.code)return;throw err;}if(areIdentical(srcStat,destStat))throw Error(errMsg(src,dest,funcName));return checkParentPathsSync(src,\nsrcStat,destParent,funcName)}}function areIdentical(srcStat,destStat){return destStat.ino&&destStat.dev&&destStat.ino===srcStat.ino&&destStat.dev===srcStat.dev}function isSrcSubdir(src,dest){src=path.resolve(src).split(path.sep).filter(i=>i);const destArr=path.resolve(dest).split(path.sep).filter(i=>i);return src.reduce((acc,cur,i)=>acc&&destArr[i]===cur,!0)}function errMsg(src,dest,funcName){return`Cannot ${funcName} '${src}' to a subdirectory of itself, '${dest}'.`}const fs=require(\"module$node_modules$fs_extra$lib$fs$index\"),\npath=require(\"module$node_modules$path_browserify$index\"),util=require(\"module$node_modules$util$util\");module.exports={checkPaths:function(src,dest,funcName,opts,cb){util.callbackify(getStats)(src,dest,opts,(err,stats)=>{if(err)return cb(err);const {srcStat,destStat}=stats;if(destStat){if(areIdentical(srcStat,destStat))return err=path.basename(src),stats=path.basename(dest),\"move\"===funcName&&err!==stats&&err.toLowerCase()===stats.toLowerCase()?cb(null,{srcStat,destStat,isChangingCase:!0}):cb(Error(\"Source and destination must not be the same.\"));\nif(srcStat.isDirectory()&&!destStat.isDirectory())return cb(Error(`Cannot overwrite non-directory '${dest}' with directory '${src}'.`));if(!srcStat.isDirectory()&&destStat.isDirectory())return cb(Error(`Cannot overwrite directory '${dest}' with non-directory '${src}'.`))}return srcStat.isDirectory()&&isSrcSubdir(src,dest)?cb(Error(errMsg(src,dest,funcName))):cb(null,{srcStat,destStat})})},checkPathsSync:function(src,dest,funcName,opts){const {srcStat,destStat}=getStatsSync(src,dest,opts);if(destStat){if(areIdentical(srcStat,\ndestStat)){src=path.basename(src);dest=path.basename(dest);if(\"move\"===funcName&&src!==dest&&src.toLowerCase()===dest.toLowerCase())return{srcStat,destStat,isChangingCase:!0};throw Error(\"Source and destination must not be the same.\");}if(srcStat.isDirectory()&&!destStat.isDirectory())throw Error(`Cannot overwrite non-directory '${dest}' with directory '${src}'.`);if(!srcStat.isDirectory()&&destStat.isDirectory())throw Error(`Cannot overwrite directory '${dest}' with non-directory '${src}'.`);}if(srcStat.isDirectory()&&\nisSrcSubdir(src,dest))throw Error(errMsg(src,dest,funcName));return{srcStat,destStat}},checkParentPaths,checkParentPathsSync,isSrcSubdir,areIdentical}}","~:source","shadow$provide[\"module$node_modules$fs_extra$lib$util$stat\"] = function(global,require,module,exports) {\n'use strict'\n\nconst fs = require('../fs')\nconst path = require('path')\nconst util = require('util')\n\nfunction getStats (src, dest, opts) {\n  const statFunc = opts.dereference\n    ? (file) => fs.stat(file, { bigint: true })\n    : (file) => fs.lstat(file, { bigint: true })\n  return Promise.all([\n    statFunc(src),\n    statFunc(dest).catch(err => {\n      if (err.code === 'ENOENT') return null\n      throw err\n    })\n  ]).then(([srcStat, destStat]) => ({ srcStat, destStat }))\n}\n\nfunction getStatsSync (src, dest, opts) {\n  let destStat\n  const statFunc = opts.dereference\n    ? (file) => fs.statSync(file, { bigint: true })\n    : (file) => fs.lstatSync(file, { bigint: true })\n  const srcStat = statFunc(src)\n  try {\n    destStat = statFunc(dest)\n  } catch (err) {\n    if (err.code === 'ENOENT') return { srcStat, destStat: null }\n    throw err\n  }\n  return { srcStat, destStat }\n}\n\nfunction checkPaths (src, dest, funcName, opts, cb) {\n  util.callbackify(getStats)(src, dest, opts, (err, stats) => {\n    if (err) return cb(err)\n    const { srcStat, destStat } = stats\n\n    if (destStat) {\n      if (areIdentical(srcStat, destStat)) {\n        const srcBaseName = path.basename(src)\n        const destBaseName = path.basename(dest)\n        if (funcName === 'move' &&\n          srcBaseName !== destBaseName &&\n          srcBaseName.toLowerCase() === destBaseName.toLowerCase()) {\n          return cb(null, { srcStat, destStat, isChangingCase: true })\n        }\n        return cb(new Error('Source and destination must not be the same.'))\n      }\n      if (srcStat.isDirectory() && !destStat.isDirectory()) {\n        return cb(new Error(`Cannot overwrite non-directory '${dest}' with directory '${src}'.`))\n      }\n      if (!srcStat.isDirectory() && destStat.isDirectory()) {\n        return cb(new Error(`Cannot overwrite directory '${dest}' with non-directory '${src}'.`))\n      }\n    }\n\n    if (srcStat.isDirectory() && isSrcSubdir(src, dest)) {\n      return cb(new Error(errMsg(src, dest, funcName)))\n    }\n    return cb(null, { srcStat, destStat })\n  })\n}\n\nfunction checkPathsSync (src, dest, funcName, opts) {\n  const { srcStat, destStat } = getStatsSync(src, dest, opts)\n\n  if (destStat) {\n    if (areIdentical(srcStat, destStat)) {\n      const srcBaseName = path.basename(src)\n      const destBaseName = path.basename(dest)\n      if (funcName === 'move' &&\n        srcBaseName !== destBaseName &&\n        srcBaseName.toLowerCase() === destBaseName.toLowerCase()) {\n        return { srcStat, destStat, isChangingCase: true }\n      }\n      throw new Error('Source and destination must not be the same.')\n    }\n    if (srcStat.isDirectory() && !destStat.isDirectory()) {\n      throw new Error(`Cannot overwrite non-directory '${dest}' with directory '${src}'.`)\n    }\n    if (!srcStat.isDirectory() && destStat.isDirectory()) {\n      throw new Error(`Cannot overwrite directory '${dest}' with non-directory '${src}'.`)\n    }\n  }\n\n  if (srcStat.isDirectory() && isSrcSubdir(src, dest)) {\n    throw new Error(errMsg(src, dest, funcName))\n  }\n  return { srcStat, destStat }\n}\n\n// recursively check if dest parent is a subdirectory of src.\n// It works for all file types including symlinks since it\n// checks the src and dest inodes. It starts from the deepest\n// parent and stops once it reaches the src parent or the root path.\nfunction checkParentPaths (src, srcStat, dest, funcName, cb) {\n  const srcParent = path.resolve(path.dirname(src))\n  const destParent = path.resolve(path.dirname(dest))\n  if (destParent === srcParent || destParent === path.parse(destParent).root) return cb()\n  fs.stat(destParent, { bigint: true }, (err, destStat) => {\n    if (err) {\n      if (err.code === 'ENOENT') return cb()\n      return cb(err)\n    }\n    if (areIdentical(srcStat, destStat)) {\n      return cb(new Error(errMsg(src, dest, funcName)))\n    }\n    return checkParentPaths(src, srcStat, destParent, funcName, cb)\n  })\n}\n\nfunction checkParentPathsSync (src, srcStat, dest, funcName) {\n  const srcParent = path.resolve(path.dirname(src))\n  const destParent = path.resolve(path.dirname(dest))\n  if (destParent === srcParent || destParent === path.parse(destParent).root) return\n  let destStat\n  try {\n    destStat = fs.statSync(destParent, { bigint: true })\n  } catch (err) {\n    if (err.code === 'ENOENT') return\n    throw err\n  }\n  if (areIdentical(srcStat, destStat)) {\n    throw new Error(errMsg(src, dest, funcName))\n  }\n  return checkParentPathsSync(src, srcStat, destParent, funcName)\n}\n\nfunction areIdentical (srcStat, destStat) {\n  return destStat.ino && destStat.dev && destStat.ino === srcStat.ino && destStat.dev === srcStat.dev\n}\n\n// return true if dest is a subdir of src, otherwise false.\n// It only checks the path strings.\nfunction isSrcSubdir (src, dest) {\n  const srcArr = path.resolve(src).split(path.sep).filter(i => i)\n  const destArr = path.resolve(dest).split(path.sep).filter(i => i)\n  return srcArr.reduce((acc, cur, i) => acc && destArr[i] === cur, true)\n}\n\nfunction errMsg (src, dest, funcName) {\n  return `Cannot ${funcName} '${src}' to a subdirectory of itself, '${dest}'.`\n}\n\nmodule.exports = {\n  checkPaths,\n  checkPathsSync,\n  checkParentPaths,\n  checkParentPathsSync,\n  isSrcSubdir,\n  areIdentical\n}\n\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$shadow.js","~$module$node_modules$path_browserify$index","~$module$node_modules$fs_extra$lib$fs$index","~$module$node_modules$util$util"]],"~:properties",["^5",["srcStat","isChangingCase","checkParentPaths","checkPaths","destStat","areIdentical","bigint","checkPathsSync","isSrcSubdir","checkParentPathsSync"]],"~:compiled-at",1683799130888,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$fs_extra$lib$util$stat.js\",\n\"lineCount\":8,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/fs-extra/lib/util/stat.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$fs_extra$lib$util$stat\\\"] = function(global,require,module,exports) {\\n'use strict'\\n\\nconst fs = require('../fs')\\nconst path = require('path')\\nconst util = require('util')\\n\\nfunction getStats (src, dest, opts) {\\n  const statFunc = opts.dereference\\n    ? (file) => fs.stat(file, { bigint: true })\\n    : (file) => fs.lstat(file, { bigint: true })\\n  return Promise.all([\\n    statFunc(src),\\n    statFunc(dest).catch(err => {\\n      if (err.code === 'ENOENT') return null\\n      throw err\\n    })\\n  ]).then(([srcStat, destStat]) => ({ srcStat, destStat }))\\n}\\n\\nfunction getStatsSync (src, dest, opts) {\\n  let destStat\\n  const statFunc = opts.dereference\\n    ? (file) => fs.statSync(file, { bigint: true })\\n    : (file) => fs.lstatSync(file, { bigint: true })\\n  const srcStat = statFunc(src)\\n  try {\\n    destStat = statFunc(dest)\\n  } catch (err) {\\n    if (err.code === 'ENOENT') return { srcStat, destStat: null }\\n    throw err\\n  }\\n  return { srcStat, destStat }\\n}\\n\\nfunction checkPaths (src, dest, funcName, opts, cb) {\\n  util.callbackify(getStats)(src, dest, opts, (err, stats) => {\\n    if (err) return cb(err)\\n    const { srcStat, destStat } = stats\\n\\n    if (destStat) {\\n      if (areIdentical(srcStat, destStat)) {\\n        const srcBaseName = path.basename(src)\\n        const destBaseName = path.basename(dest)\\n        if (funcName === 'move' &&\\n          srcBaseName !== destBaseName &&\\n          srcBaseName.toLowerCase() === destBaseName.toLowerCase()) {\\n          return cb(null, { srcStat, destStat, isChangingCase: true })\\n        }\\n        return cb(new Error('Source and destination must not be the same.'))\\n      }\\n      if (srcStat.isDirectory() && !destStat.isDirectory()) {\\n        return cb(new Error(`Cannot overwrite non-directory '${dest}' with directory '${src}'.`))\\n      }\\n      if (!srcStat.isDirectory() && destStat.isDirectory()) {\\n        return cb(new Error(`Cannot overwrite directory '${dest}' with non-directory '${src}'.`))\\n      }\\n    }\\n\\n    if (srcStat.isDirectory() && isSrcSubdir(src, dest)) {\\n      return cb(new Error(errMsg(src, dest, funcName)))\\n    }\\n    return cb(null, { srcStat, destStat })\\n  })\\n}\\n\\nfunction checkPathsSync (src, dest, funcName, opts) {\\n  const { srcStat, destStat } = getStatsSync(src, dest, opts)\\n\\n  if (destStat) {\\n    if (areIdentical(srcStat, destStat)) {\\n      const srcBaseName = path.basename(src)\\n      const destBaseName = path.basename(dest)\\n      if (funcName === 'move' &&\\n        srcBaseName !== destBaseName &&\\n        srcBaseName.toLowerCase() === destBaseName.toLowerCase()) {\\n        return { srcStat, destStat, isChangingCase: true }\\n      }\\n      throw new Error('Source and destination must not be the same.')\\n    }\\n    if (srcStat.isDirectory() && !destStat.isDirectory()) {\\n      throw new Error(`Cannot overwrite non-directory '${dest}' with directory '${src}'.`)\\n    }\\n    if (!srcStat.isDirectory() && destStat.isDirectory()) {\\n      throw new Error(`Cannot overwrite directory '${dest}' with non-directory '${src}'.`)\\n    }\\n  }\\n\\n  if (srcStat.isDirectory() && isSrcSubdir(src, dest)) {\\n    throw new Error(errMsg(src, dest, funcName))\\n  }\\n  return { srcStat, destStat }\\n}\\n\\n// recursively check if dest parent is a subdirectory of src.\\n// It works for all file types including symlinks since it\\n// checks the src and dest inodes. It starts from the deepest\\n// parent and stops once it reaches the src parent or the root path.\\nfunction checkParentPaths (src, srcStat, dest, funcName, cb) {\\n  const srcParent = path.resolve(path.dirname(src))\\n  const destParent = path.resolve(path.dirname(dest))\\n  if (destParent === srcParent || destParent === path.parse(destParent).root) return cb()\\n  fs.stat(destParent, { bigint: true }, (err, destStat) => {\\n    if (err) {\\n      if (err.code === 'ENOENT') return cb()\\n      return cb(err)\\n    }\\n    if (areIdentical(srcStat, destStat)) {\\n      return cb(new Error(errMsg(src, dest, funcName)))\\n    }\\n    return checkParentPaths(src, srcStat, destParent, funcName, cb)\\n  })\\n}\\n\\nfunction checkParentPathsSync (src, srcStat, dest, funcName) {\\n  const srcParent = path.resolve(path.dirname(src))\\n  const destParent = path.resolve(path.dirname(dest))\\n  if (destParent === srcParent || destParent === path.parse(destParent).root) return\\n  let destStat\\n  try {\\n    destStat = fs.statSync(destParent, { bigint: true })\\n  } catch (err) {\\n    if (err.code === 'ENOENT') return\\n    throw err\\n  }\\n  if (areIdentical(srcStat, destStat)) {\\n    throw new Error(errMsg(src, dest, funcName))\\n  }\\n  return checkParentPathsSync(src, srcStat, destParent, funcName)\\n}\\n\\nfunction areIdentical (srcStat, destStat) {\\n  return destStat.ino && destStat.dev && destStat.ino === srcStat.ino && destStat.dev === srcStat.dev\\n}\\n\\n// return true if dest is a subdir of src, otherwise false.\\n// It only checks the path strings.\\nfunction isSrcSubdir (src, dest) {\\n  const srcArr = path.resolve(src).split(path.sep).filter(i => i)\\n  const destArr = path.resolve(dest).split(path.sep).filter(i => i)\\n  return srcArr.reduce((acc, cur, i) => acc && destArr[i] === cur, true)\\n}\\n\\nfunction errMsg (src, dest, funcName) {\\n  return `Cannot ${funcName} '${src}' to a subdirectory of itself, '${dest}'.`\\n}\\n\\nmodule.exports = {\\n  checkPaths,\\n  checkPathsSync,\\n  checkParentPaths,\\n  checkParentPathsSync,\\n  isSrcSubdir,\\n  areIdentical\\n}\\n\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"getStats\",\"src\",\"dest\",\"opts\",\"statFunc\",\"dereference\",\"file\",\"fs\",\"stat\",\"bigint\",\"lstat\",\"Promise\",\"all\",\"catch\",\"err\",\"code\",\"then\",\"srcStat\",\"destStat\",\"getStatsSync\",\"statSync\",\"lstatSync\",\"checkParentPaths\",\"funcName\",\"cb\",\"srcParent\",\"path\",\"resolve\",\"dirname\",\"destParent\",\"parse\",\"root\",\"areIdentical\",\"Error\",\"errMsg\",\"checkParentPathsSync\",\"ino\",\"dev\",\"isSrcSubdir\",\"srcArr\",\"split\",\"sep\",\"filter\",\"i\",\"destArr\",\"reduce\",\"acc\",\"cur\",\"util\",\"checkPaths\",\"callbackify\",\"stats\",\"srcBaseName\",\"basename\",\"destBaseName\",\"toLowerCase\",\"isChangingCase\",\"isDirectory\",\"checkPathsSync\"]\n}\n"]